import { union, string, object, number, boolean, optional, array, tuple, nativeEnum, literal, record, any } from 'valibot';
import 'fflate';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var NumericStringBooleanType = union([string("Numeric"), string("String"), string("Boolean")]);
var GuardSchema = object({
  type: NumericStringBooleanType,
  context_key: string(),
  condition_type: string(),
  compare_to: union([string(), number(), boolean()])
});
var NumericEventSchema = object({ value: number() });
var BooleanEventSchema = object({ value: boolean() });
var StringEventSchema = object({ value: string() });
var PointerEventSchema = object({ target: optional(string()) });
var TransitionType = string("Transition");
var TransitionSchema = object({
  type: TransitionType,
  from_state: number(),
  to_state: number(),
  guards: optional(array(GuardSchema)),
  numeric_event: optional(NumericEventSchema),
  boolean_event: optional(BooleanEventSchema),
  string_event: optional(StringEventSchema),
  on_complete_event: optional(object({})),
  on_pointer_down_event: optional(PointerEventSchema),
  on_pointer_up_event: optional(PointerEventSchema),
  on_pointer_enter_event: optional(PointerEventSchema),
  on_pointer_exit_event: optional(PointerEventSchema),
  on_pointer_move_event: optional(PointerEventSchema)
});
var TransitionsSchema = array(TransitionSchema);
var URLActionSchema = object({ type: string(), url: string(), target: string() });
var ThemeActionSchema = object({ type: string(), themeId: string() });
var SoundActionSchema = object({ type: string(), soundId: string() });
var LogActionSchema = object({ type: string(), message: string() });
var ActionSchema = union([URLActionSchema, ThemeActionSchema, SoundActionSchema, LogActionSchema]);
var Modes = union([string("Forward"), string("Reverse"), string("Bounce"), string("ReverseBounce")]);
var StateType = union([string("PlaybackState"), string("FinalState"), string("SyncState"), string("GobalState")]);
var PlaybackStateSchema = object({
  name: string(),
  type: StateType,
  animation_id: optional(string()),
  loop: optional(boolean()),
  autoplay: optional(boolean()),
  mode: optional(Modes),
  speed: optional(number()),
  marker: optional(string()),
  background_color: optional(number()),
  segment: optional(optional(tuple([number(), number()]))),
  use_frame_interpolation: optional(boolean()),
  reset_context: optional(string()),
  entry_actions: optional(array(ActionSchema)),
  exit_actions: optional(array(ActionSchema))
});
var SyncStateSchema = object({
  name: string(),
  type: StateType,
  animation_id: optional(string()),
  frame_context_key: string(),
  background_color: optional(number()),
  segment: optional(optional(tuple([number(), number()]))),
  reset_context: optional(string()),
  entry_actions: optional(array(ActionSchema)),
  exit_actions: optional(array(ActionSchema))
});
var FinalStateSchema = object({
  name: string(),
  type: StateType,
  reset_context: optional(string()),
  entry_actions: optional(array(ActionSchema)),
  exit_actions: optional(array(ActionSchema))
});
var GlobalStateSchema = object({
  name: string(),
  type: StateType,
  reset_context: optional(string()),
  entry_actions: optional(array(ActionSchema)),
  exit_actions: optional(array(ActionSchema))
});
var StateSchema = union([PlaybackStateSchema, SyncStateSchema, FinalStateSchema, GlobalStateSchema]);
var StatesSchema = array(StateSchema);
var ListenerSchema = object({
  type: string(),
  target: optional(string()),
  action: optional(string()),
  value: optional(union([string(), boolean(), number()])),
  context_key: optional(string())
});
var ListenersSchemas = array(ListenerSchema);
var ContextVariableSchema = object({
  type: NumericStringBooleanType,
  key: string(),
  value: union([number(), string(), boolean()])
});
var ContextVariablesSchema = array(ContextVariableSchema);
var DescriptorSchema = object({
  id: string(),
  initial: number()
});
object({
  descriptor: DescriptorSchema,
  states: StatesSchema,
  transitions: TransitionsSchema,
  listeners: ListenersSchemas,
  context_variables: ContextVariablesSchema
});
var PlayMode = /* @__PURE__ */ ((PlayMode2) => {
  PlayMode2["Bounce"] = "bounce";
  PlayMode2["Normal"] = "normal";
  return PlayMode2;
})(PlayMode || {});
var PlayModeSchema = nativeEnum(PlayMode);
var ManifestAnimationSchema = object({
  autoplay: optional(boolean()),
  defaultTheme: optional(string()),
  direction: optional(union([literal(1), literal(-1)])),
  hover: optional(boolean()),
  id: string(),
  intermission: optional(number()),
  loop: optional(union([boolean(), number()])),
  playMode: optional(PlayModeSchema),
  speed: optional(number()),
  themeColor: optional(string())
});
var ManifestThemeSchema = object({
  animations: array(string()),
  id: string()
});
object({
  activeAnimationId: optional(string()),
  animations: array(ManifestAnimationSchema),
  author: optional(string()),
  custom: optional(record(string(), any())),
  description: optional(string()),
  generator: optional(string()),
  keywords: optional(string()),
  revision: optional(number()),
  themes: optional(array(ManifestThemeSchema)),
  states: optional(array(string())),
  version: optional(string())
});

// src/common/utils.ts
var createError = (message) => {
  const error = new Error(`[dotlottie-js]: ${message}`);
  return error;
};
var isValidURL = (url) => {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
};

// src/common/dotlottie-theme-common.ts
var LottieThemeCommon = class {
  constructor(options) {
    __publicField(this, "_data");
    __publicField(this, "_id", "");
    __publicField(this, "_url");
    __publicField(this, "_animationsMap", /* @__PURE__ */ new Map());
    __publicField(this, "_zipOptions");
    this._requireValidId(options.id);
    this._id = options.id;
    if (options.data) {
      this._requireValidData(options.data);
      this._data = options.data;
    }
    if (options.url) {
      this._requireValidUrl(options.url);
      this._url = options.url;
    }
    this._zipOptions = options.zipOptions ?? {};
  }
  get zipOptions() {
    return this._zipOptions;
  }
  set zipOptions(zipOptions) {
    this._zipOptions = zipOptions;
  }
  get id() {
    return this._id;
  }
  set id(id) {
    this._requireValidId(id);
    this._id = id;
  }
  get url() {
    return this._url;
  }
  set url(url) {
    this._requireValidUrl(url);
    this._url = url;
  }
  get data() {
    return this._data;
  }
  set data(data) {
    this._requireValidData(data);
    this._data = data;
  }
  get animations() {
    return Array.from(this._animationsMap.values());
  }
  async toString() {
    if (!this._data && this._url) {
      await this._loadDataFromUrl(this._url);
    }
    this._requireValidData(this._data);
    return JSON.stringify(this._data);
  }
  addAnimation(animation) {
    this._animationsMap.set(animation.id, animation);
  }
  removeAnimation(animationId) {
    this._animationsMap.delete(animationId);
  }
  _requireValidId(id) {
    if (typeof id !== "string" || !id)
      throw createError("Invalid theme id");
  }
  _requireValidUrl(url) {
    if (!url || !isValidURL(url))
      throw createError("Invalid theme url");
  }
  _requireValidData(data) {
    if (typeof data !== "object")
      throw createError("Invalid theme data");
  }
  async _loadDataFromUrl(url) {
    try {
      const response = await fetch(url);
      const data = await response.json();
      this._data = data;
    } catch (error) {
      throw createError(`Failed to fetch theme from url, Error: ${JSON.stringify(error)}`);
    }
  }
};

// src/lottie-theme.ts
var LottieTheme = class extends LottieThemeCommon {
  constructor(options) {
    super(options);
  }
};

export { LottieTheme };
//# sourceMappingURL=lottie-theme.js.map