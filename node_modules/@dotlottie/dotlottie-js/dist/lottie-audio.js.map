{"version":3,"sources":["../src/common/dotlottie-state-machine-common.ts","../src/common/dotlottie-state.ts","../src/common/utils.ts","../src/common/manifest.ts","../src/common/lottie-audio-common.ts","../src/lottie-audio.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { ZipOptions } from 'fflate';\nimport { safeParse, flatten } from 'valibot';\n\nimport type {\n  DotLottieContextVariables,\n  DotLottieDescriptor,\n  DotLottieListener,\n  DotLottieListeners,\n  DotLottieStates,\n  DotLottieTransition,\n  DotLottieTransitions,\n} from './dotlottie-state';\nimport {\n  ContextVariablesSchema,\n  DescriptorSchema,\n  ListenersSchemas,\n  StatesSchema,\n  TransitionsSchema,\n} from './dotlottie-state';\nimport { DotLottieError, ErrorCodes } from './utils';\n\nexport interface DotLottieStateMachineCommonOptions {\n  context_variables: DotLottieContextVariables;\n  descriptor: DotLottieDescriptor;\n  listeners: DotLottieListeners;\n  states: DotLottieStates;\n  transitions: DotLottieTransitions;\n  zipOptions?: ZipOptions;\n}\n\nexport class DotLottieStateMachineCommon {\n  protected _descriptor: DotLottieDescriptor;\n\n  protected _zipOptions: ZipOptions;\n\n  protected _states: DotLottieStates;\n\n  protected _transitions: DotLottieTransition[];\n\n  protected _listeners: DotLottieListener[];\n\n  protected _contextVariables: DotLottieContextVariables;\n\n  public constructor(options: DotLottieStateMachineCommonOptions) {\n    this._requireValidContextVariables(options.context_variables);\n    this._requireValidListeners(options.listeners);\n    this._requireValidTransitions(options.transitions);\n    this._requireValidId(options.descriptor.id);\n    this._requireValidStates(options.states);\n    this._requireValidDescriptor(options.descriptor);\n\n    this._descriptor = options.descriptor;\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    this._states = options.states;\n\n    this._descriptor = options.descriptor;\n\n    this._listeners = options.listeners;\n\n    this._transitions = options.transitions;\n\n    this._contextVariables = options.context_variables;\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  public get id(): string {\n    return this._descriptor.id;\n  }\n\n  public set id(id: string) {\n    this._requireValidId(id);\n\n    this._descriptor.id = id;\n  }\n\n  public get states(): DotLottieStates {\n    return this._states;\n  }\n\n  public set states(states: DotLottieStates) {\n    this._states = states;\n  }\n\n  public get transitions(): DotLottieTransition[] {\n    return this._transitions;\n  }\n\n  public set transitions(transitions: DotLottieTransition[]) {\n    this._transitions = transitions;\n  }\n\n  public get listeners(): DotLottieListener[] {\n    return this._listeners;\n  }\n\n  public set listeners(listeners: DotLottieListener[]) {\n    this._listeners = listeners;\n  }\n\n  public get contextVariables(): DotLottieContextVariables {\n    return this._contextVariables;\n  }\n\n  public set contextVariables(contextVariables: DotLottieContextVariables) {\n    this._contextVariables = contextVariables;\n  }\n\n  public get initial(): number {\n    return this._descriptor.initial;\n  }\n\n  public set initial(initial: number) {\n    this._descriptor.initial = initial;\n  }\n\n  public get descriptor(): DotLottieDescriptor {\n    return this._descriptor;\n  }\n\n  public set descriptor(descriptor: DotLottieDescriptor) {\n    this._descriptor = descriptor;\n  }\n\n  public toString(): string {\n    return JSON.stringify({\n      descriptor: this._descriptor,\n      states: this._states,\n      transitions: this._transitions,\n      context_variables: this._contextVariables,\n      listeners: this._listeners,\n    });\n  }\n\n  protected _requireValidId(id: string | undefined): void {\n    if (!id) {\n      throw new DotLottieError('Invalid id.');\n    }\n  }\n\n  protected _requireValidDescriptor(descriptor: DotLottieDescriptor): void {\n    const result = safeParse(DescriptorSchema, descriptor);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.issues).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid descriptor: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n\n  protected _requireValidStates(states: DotLottieStates): void {\n    const result = safeParse(StatesSchema, states);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.issues).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid states: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n\n  protected _requireValidContextVariables(contextVariables: DotLottieContextVariables): void {\n    const result = safeParse(ContextVariablesSchema, contextVariables);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.issues).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid context variables: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n\n  protected _requireValidListeners(listeners: DotLottieListeners): void {\n    const result = safeParse(ListenersSchemas, listeners);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.issues).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid listeners: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n\n  protected _requireValidTransitions(transitions: DotLottieTransitions): void {\n    const result = safeParse(TransitionsSchema, transitions);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.issues).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid transitions: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { Output } from 'valibot';\nimport { boolean, number, object, optional, string, array, union, tuple } from 'valibot';\n\nconst NumericStringBooleanType = union([string('Numeric'), string('String'), string('Boolean')]);\n\n// Guard Schema\nexport const GuardSchema = object({\n  type: NumericStringBooleanType,\n  context_key: string(),\n  condition_type: string(),\n  compare_to: union([string(), number(), boolean()]),\n});\n\n// Event Schemas\nconst NumericEventSchema = object({ value: number() });\nconst BooleanEventSchema = object({ value: boolean() });\nconst StringEventSchema = object({ value: string() });\nconst PointerEventSchema = object({ target: optional(string()) });\n\n// const TransitionType = union([string('Transition')]);\nconst TransitionType = string('Transition');\n\n// Transition Schema\nexport const TransitionSchema = object({\n  type: TransitionType,\n  from_state: number(),\n  to_state: number(),\n  guards: optional(array(GuardSchema)),\n  numeric_event: optional(NumericEventSchema),\n  boolean_event: optional(BooleanEventSchema),\n  string_event: optional(StringEventSchema),\n  on_complete_event: optional(object({})),\n  on_pointer_down_event: optional(PointerEventSchema),\n  on_pointer_up_event: optional(PointerEventSchema),\n  on_pointer_enter_event: optional(PointerEventSchema),\n  on_pointer_exit_event: optional(PointerEventSchema),\n  on_pointer_move_event: optional(PointerEventSchema),\n});\n\nexport const TransitionsSchema = array(TransitionSchema);\n\n// Entry/Exit Action Schema\nconst URLActionSchema = object({ type: string(), url: string(), target: string() });\nconst ThemeActionSchema = object({ type: string(), themeId: string() });\nconst SoundActionSchema = object({ type: string(), soundId: string() });\nconst LogActionSchema = object({ type: string(), message: string() });\n\nconst ActionSchema = union([URLActionSchema, ThemeActionSchema, SoundActionSchema, LogActionSchema]);\n\nconst Modes = union([string('Forward'), string('Reverse'), string('Bounce'), string('ReverseBounce')]);\n\nconst StateType = union([string('PlaybackState'), string('FinalState'), string('SyncState'), string('GobalState')]);\n\nexport const PlaybackStateSchema = object({\n  name: string(),\n  type: StateType,\n  animation_id: optional(string()),\n  loop: optional(boolean()),\n  autoplay: optional(boolean()),\n  mode: optional(Modes),\n  speed: optional(number()),\n  marker: optional(string()),\n  background_color: optional(number()),\n  segment: optional(optional(tuple([number(), number()]))),\n  use_frame_interpolation: optional(boolean()),\n  reset_context: optional(string()),\n  entry_actions: optional(array(ActionSchema)),\n  exit_actions: optional(array(ActionSchema)),\n});\n\nexport const SyncStateSchema = object({\n  name: string(),\n  type: StateType,\n  animation_id: optional(string()),\n  frame_context_key: string(),\n  background_color: optional(number()),\n  segment: optional(optional(tuple([number(), number()]))),\n  reset_context: optional(string()),\n  entry_actions: optional(array(ActionSchema)),\n  exit_actions: optional(array(ActionSchema)),\n});\n\nexport const FinalStateSchema = object({\n  name: string(),\n  type: StateType,\n  reset_context: optional(string()),\n  entry_actions: optional(array(ActionSchema)),\n  exit_actions: optional(array(ActionSchema)),\n});\n\nexport const GlobalStateSchema = object({\n  name: string(),\n  type: StateType,\n  reset_context: optional(string()),\n  entry_actions: optional(array(ActionSchema)),\n  exit_actions: optional(array(ActionSchema)),\n});\n\nexport const StateSchema = union([PlaybackStateSchema, SyncStateSchema, FinalStateSchema, GlobalStateSchema]);\nexport const StatesSchema = array(StateSchema);\n\n// Listener Schema\nexport const ListenerSchema = object({\n  type: string(),\n  target: optional(string()),\n  action: optional(string()),\n  value: optional(union([string(), boolean(), number()])),\n  context_key: optional(string()),\n});\n\nexport const ListenersSchemas = array(ListenerSchema);\n\n// Context Variable Schema\nexport const ContextVariableSchema = object({\n  type: NumericStringBooleanType,\n  key: string(),\n  value: union([number(), string(), boolean()]),\n});\n\nexport const ContextVariablesSchema = array(ContextVariableSchema);\n\n// Descriptor Schema\nexport const DescriptorSchema = object({\n  id: string(),\n  initial: number(),\n});\n\nexport type DotLottieStates = Output<typeof StatesSchema>;\nexport type DotLottieDescriptor = Output<typeof DescriptorSchema>;\nexport type DotLottieState = Output<typeof StateSchema>;\nexport type DotLottieAction = Output<typeof ActionSchema>;\nexport type DotLottieNumericEvent = Output<typeof NumericEventSchema>;\nexport type DotLottieBooleanEvent = Output<typeof BooleanEventSchema>;\nexport type DotLottieStringEvent = Output<typeof StringEventSchema>;\nexport type DotLottiePointerEvent = Output<typeof PointerEventSchema>;\nexport type DotLottieGuard = Output<typeof GuardSchema>;\nexport type DotLottieContextVariables = Output<typeof ContextVariablesSchema>;\nexport type DotLottieListener = Output<typeof ListenerSchema>;\nexport type DotLottieListeners = Output<typeof ListenersSchemas>;\nexport type DotLottieTransition = Output<typeof TransitionSchema>;\nexport type DotLottieTransitions = Output<typeof TransitionsSchema>;\n\n// DotLottieStateMachine Schema\nexport const DotLottieStateMachineSchema = object({\n  descriptor: DescriptorSchema,\n  states: StatesSchema,\n  transitions: TransitionsSchema,\n  listeners: ListenersSchemas,\n  context_variables: ContextVariablesSchema,\n});\nexport type DotLottieStateMachine = Output<typeof DotLottieStateMachineSchema>;\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/* eslint-disable guard-for-in */\n\nimport type { Animation as AnimationData, Asset } from '@lottie-animation-community/lottie-types';\nimport type { UnzipFileFilter, Unzipped } from 'fflate';\nimport { unzip as fflateUnzip, strFromU8 } from 'fflate';\nimport { flatten, safeParse } from 'valibot';\n\nimport type { LottieStateMachine } from '../lottie-state-machine';\n\nimport type { Manifest } from './manifest';\nimport { ManifestSchema } from './manifest';\n\nexport interface MimeTypes {\n  [key: string]: string;\n}\n\nexport interface MimeCodes {\n  [key: string]: number[];\n}\n\nexport const MIME_TYPES: MimeTypes = {\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  gif: 'image/gif',\n  bmp: 'image/bmp',\n  svg: 'image/svg+xml',\n  svgxml: 'image/svg+xml',\n  webp: 'image/webp',\n  mp3: 'audio/mp3',\n};\n\nexport const MIME_CODES: MimeCodes = {\n  jpeg: [0xff, 0xd8, 0xff],\n  png: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],\n  gif: [0x47, 0x49, 0x46],\n  bmp: [0x42, 0x4d],\n  webp: [0x52, 0x49, 0x46, 0x46, 0x3f, 0x3f, 0x3f, 0x3f, 0x57, 0x45, 0x42, 0x50],\n  // This covers <svg..\n  svg: [0x3c, 0x73, 0x76, 0x67],\n  // This covers <?xml..\n  svgxml: [0x3c, 0x3f, 0x78, 0x6d, 0x6c],\n  mp3: [0x49, 0x44, 0x33],\n};\n\nexport interface MimeToExtension {\n  [key: string]: string;\n}\n\nexport const MIME_TO_EXTENSION: MimeToExtension = {\n  'image/jpeg': 'jpeg',\n  'image/png': 'png',\n  'image/gif': 'gif',\n  'image/bmp': 'bmp',\n  'image/svg+xml': 'svg',\n  'image/webp': 'webp',\n  'audio/mpeg': 'mpeg',\n  'audio/mp3': 'mp3',\n};\n\nexport enum ErrorCodes {\n  ASSET_NOT_FOUND = 'ASSET_NOT_FOUND',\n  INVALID_DOTLOTTIE = 'INVALID_DOTLOTTIE',\n  INVALID_STATEMACHINE = 'INVALID_STATEMACHINE',\n  INVALID_URL = 'INVALID_URL',\n}\n\nexport class DotLottieError extends Error {\n  public code: ErrorCodes | undefined;\n\n  public constructor(message: string, code?: ErrorCodes) {\n    super(message);\n    this.name = '[dotlottie-js]';\n    this.code = code;\n  }\n}\n\n/**\n * Creates an Error object with the specified message.\n *\n * @remarks\n * This function accepts a message string and constructs a new Error object prefixed with \"[dotlottie-js]: \".\n *\n * @deprecated\n * This function has been deprecated in favor of using the {@link DotLottieError} class directly.\n *\n * @param message - The error message to include in the Error object.\n * @returns An Error object with the specified message, prefixed with \"[dotlottie-js]: \".\n *\n * @example\n * ```typescript\n * const message = 'DotLottie not found';\n * const error = createError(message);\n * ```\n *\n * @public\n */\nexport const createError = (message: string): Error => {\n  const error = new Error(`[dotlottie-js]: ${message}`);\n\n  return error;\n};\n\n/**\n * Converts a base64 string into a Uint8Array.\n *\n * @remarks\n * This function accepts a base64 string and returns a Uint8Array containing the decoded bytes.\n *\n * @param base64String - The base64-encoded string to decode.\n * @returns A Uint8Array containing the decoded bytes.\n *\n * @example\n * ```typescript\n * const base64 = 'SGVsbG8gd29ybGQ=';\n * const array = base64ToUint8Array(base64);\n * ```\n *\n * @public\n */\nexport const base64ToUint8Array = (base64String: string): Uint8Array => {\n  const withoutMeta = base64String.substring(base64String.indexOf(',') + 1);\n  const binaryString =\n    typeof window === 'undefined' ? Buffer.from(withoutMeta, 'base64').toString('binary') : atob(withoutMeta);\n\n  const uint8Array = new Uint8Array(binaryString.length);\n\n  for (let i = 0; i < binaryString.length; i += 1) {\n    uint8Array[i] = binaryString.charCodeAt(i);\n  }\n\n  return uint8Array;\n};\n\n/**\n * Determines the MIME type from a base64-encoded string.\n *\n * @remarks\n * This function accepts a base64-encoded string and determines its MIME type by looking at the first few bytes.\n *\n * @param base64 - The base64-encoded string to analyze.\n * @returns The MIME type as a string, or null if the type cannot be determined.\n *\n * @example\n * ```typescript\n * const base64 = 'data:image/jpeg;base64,...';\n * const mimeType = getMimeTypeFromBase64(base64);\n * ```\n *\n * @public\n */\nexport const getMimeTypeFromBase64 = (base64: string): string | undefined => {\n  let data: string | null = null;\n  let bytes: number[] = [];\n\n  if (!base64) {\n    throw new DotLottieError(\n      'Failed to determine the MIME type from the base64 asset string. Please check the input data. Supported asset types for dotlottie-js  are: jpeg, png, gif, bmp, svg, webp, mp3',\n      ErrorCodes.INVALID_DOTLOTTIE,\n    );\n  }\n\n  const withoutMeta = base64.substring(base64.indexOf(',') + 1);\n\n  if (typeof window === 'undefined') {\n    data = Buffer.from(withoutMeta, 'base64').toString('binary');\n  } else {\n    data = atob(withoutMeta);\n  }\n\n  const bufData = new Uint8Array(data.length);\n\n  for (let i = 0; i < data.length; i += 1) {\n    bufData[i] = data.charCodeAt(i);\n  }\n\n  for (const mimeType in MIME_CODES) {\n    const dataArr = MIME_CODES[mimeType];\n\n    if (mimeType === 'webp' && dataArr && bufData.length > dataArr.length) {\n      const riffHeader = Array.from(bufData.subarray(0, 4));\n      const webpFormatMarker = Array.from(bufData.subarray(8, 12));\n\n      if (\n        riffHeader.every((byte, index) => byte === dataArr[index]) &&\n        webpFormatMarker.every((byte, index) => byte === dataArr[index + 8])\n      ) {\n        return MIME_TYPES[mimeType];\n      }\n    } else {\n      bytes = Array.from(bufData.subarray(0, dataArr?.length));\n\n      if (dataArr && bytes.every((byte, index) => byte === dataArr[index])) {\n        return MIME_TYPES[mimeType];\n      }\n    }\n  }\n\n  throw new DotLottieError(\n    'Failed to determine the MIME type from the base64 asset string. Please check the input data. Supported asset types for dotlottie-js  are: jpeg, png, gif, bmp, svg, webp, mp3',\n    ErrorCodes.INVALID_DOTLOTTIE,\n  );\n};\n\n/**\n * Determines the file extension from a base64-encoded string.\n *\n * @remarks\n * This function accepts a base64-encoded string and determines its file extension by examining the MIME type.\n *\n * @param base64 - The base64-encoded string to analyze.\n * @returns The file extension as a string, or 'png' if the extension cannot be determined.\n *\n * @example\n * ```typescript\n * const base64 = 'data:image/jpeg;base64,...';\n * const extension = getExtensionTypeFromBase64(base64);\n * ```\n *\n * @public\n */\nexport const getExtensionTypeFromBase64 = (base64: string): string | null => {\n  const mimeType = getMimeTypeFromBase64(base64);\n\n  if (!mimeType) {\n    const ext = base64.split(';')[0]?.split('/')[1];\n\n    if (ext) {\n      return MIME_TO_EXTENSION[ext] || null;\n    }\n\n    return null;\n  }\n\n  return MIME_TO_EXTENSION[mimeType] || null;\n};\n\n/**\n * Validates a given URL string.\n *\n * @remarks\n * This function accepts a URL string and checks whether it's a valid URL according to the URL constructor.\n * It returns `true` if the URL is valid, `false` otherwise.\n *\n * @param url - The URL string to validate.\n * @returns `true` if the URL is valid, `false` otherwise.\n *\n * @example\n * ```typescript\n * const url = 'https://example.com';\n * const isValid = isValidURL(url); // true\n * ```\n *\n * @public\n */\nexport const isValidURL = (url: string): boolean => {\n  try {\n    // eslint-disable-next-line no-new\n    new URL(url);\n\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Creates a data URL from a Uint8Array.\n *\n * @remarks\n * This function accepts a Uint8Array and a file extension, then converts the Uint8Array into a base64 data URL string.\n * The mimeType is determined based on the provided file extension, or defaults to 'image/png' if the extension is not recognized.\n *\n * @param uint8Data - The Uint8Array containing the binary data.\n * @param fileExtension - The file extension used to determine the mimeType (e.g., 'png', 'jpeg').\n * @returns The data URL string.\n *\n * @example\n * ```typescript\n * const uint8Data = new Uint8Array(...);\n * const fileExtension = 'png';\n * const dataUrl = dataUrlFromU8(uint8Data, fileExtension);\n * ```\n */\nexport function dataUrlFromU8(uint8Data: Uint8Array): string {\n  let base64: string;\n\n  if (typeof window === 'undefined') {\n    // Using Node.js Buffer for non-browser environments\n    base64 = Buffer.from(uint8Data).toString('base64');\n  } else {\n    // Using window.btoa for browser environments\n    const binaryString = Array.prototype.map.call(uint8Data, (byte: number) => String.fromCharCode(byte)).join('');\n\n    base64 = window.btoa(binaryString);\n  }\n\n  const mimeType = getMimeTypeFromBase64(base64);\n\n  return `data:${mimeType};base64,${base64}`;\n}\n\n/**\n * Checks if an asset is an image asset.\n *\n * @remarks\n * This function accepts an asset object and determines whether it represents an image asset.\n * It returns `true` if it's an image asset, `false` otherwise.\n *\n * @param asset - The asset object to check.\n * @returns `true` if it's an image asset, `false` otherwise.\n *\n * @example\n * ```typescript\n * const asset = { w: 100, h: 100, p: 'image.png' };\n * const isImage = isImageAsset(asset); // true\n * ```\n *\n * @public\n */\nexport function isImageAsset(asset: Asset.Value): asset is Asset.Image {\n  return 'w' in asset && 'h' in asset && !('xt' in asset) && 'p' in asset;\n}\n\n/**\n * Checks if an asset is an audio asset.\n *\n * @remarks\n * This function accepts an asset object and determines whether it represents an audio asset.\n * It returns `true` if it's an audio asset, `false` otherwise.\n *\n * @param asset - The asset object to check.\n * @returns `true` if it's an audio asset, `false` otherwise.\n *\n * @example\n * ```typescript\n * const asset = { e: 0, u: 'music/', p: 'audio.mp3' };\n * const isAudio = isAudioAsset(asset); // true\n * ```\n *\n * @public\n */\nexport function isAudioAsset(asset: Asset.Value): asset is Asset.Image {\n  return !('h' in asset) && !('w' in asset) && 'p' in asset && 'e' in asset && 'u' in asset && 'id' in asset;\n}\n\n/**\n * Unzips the .lottie file.\n *\n * @remarks\n * This function accepts a .lottie file as a Uint8Array and an optional filter function to refine the unzipping process.\n * It returns a Promise that resolves with the unzipped data.\n *\n * @param dotLottie - The .lottie data as a Uint8Array.\n * @param filter - The filter function to apply to the files. Defaults to a function that always returns true.\n * @returns A Promise that resolves with the unzipped data.\n * @throws {@link DotLottieError} if the .lottie data is not provided or is invalid.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const unzippedData = await unzipDotLottie(dotLottie);\n * ```\n *\n * @public\n */\nexport async function unzipDotLottie(\n  dotLottie: Uint8Array | undefined,\n  filter: UnzipFileFilter = (): boolean => true,\n): Promise<Unzipped> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    throw new DotLottieError('DotLottie not found', ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  const unzipped = await new Promise<Unzipped>((resolve, reject) => {\n    fflateUnzip(dotLottie, { filter }, (err, data) => {\n      if (err) {\n        reject(err);\n      }\n      resolve(data);\n    });\n  });\n\n  return unzipped;\n}\n\n/**\n * Unzips a specific file from a `.lottie` archive.\n *\n * @remarks\n * This function accepts a `.lottie` file as a `Uint8Array`, a path string representing the\n * target file to extract, and an optional filter function to further refine the extraction.\n * It returns a `Promise` that resolves to the unzipped `Uint8Array` of the target file.\n *\n * @param dotLottie - The `.lottie` file content as a `Uint8Array`.\n * @param path - The path of the target file within the `.lottie` archive to extract.\n * @param filter - An optional filter function to apply on the unzipping process.\n *                 Accepts a file object and returns a boolean indicating whether the file should be included.\n * @returns A `Promise` that resolves to the `Uint8Array` of the unzipped target file.\n *\n * @throws {@link DotLottieError} if the input is not a valid `.lottie` file or if the target file is not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const targetPath = 'images/image.png';\n * const unzippedFile = await unzipDotLottieFile(dotLottie, targetPath);\n * ```\n *\n * @public\n */\nexport async function unzipDotLottieFile(\n  dotLottie: Uint8Array,\n  path: string,\n  filter?: UnzipFileFilter,\n): Promise<Uint8Array | undefined> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    throw new DotLottieError('DotLottie not found', ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  const unzipped = await unzipDotLottie(dotLottie, (file) => file.name === path && (!filter || filter(file)));\n\n  return unzipped[path];\n}\n\n/**\n * Retrieves the manifest data from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and extracts the manifest data from it.\n * The manifest contains metadata information about the .lottie file, such as the list of animations, themes, and image assets.\n * It returns a Promise that resolves to the manifest data or `undefined` if the manifest is not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @returns A Promise that resolves with the manifest data or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const manifestData = await getManifest(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getManifest(dotLottie: Uint8Array): Promise<Manifest | undefined> {\n  const manifestFileName = 'manifest.json';\n\n  const unzipped = await unzipDotLottie(dotLottie, (file) => file.name === manifestFileName);\n\n  const unzippedManifest = unzipped[manifestFileName];\n\n  if (typeof unzippedManifest === 'undefined') {\n    return undefined;\n  }\n\n  return JSON.parse(strFromU8(unzippedManifest, false)) as Manifest;\n}\n\n/**\n * Validates the provided DotLottie data.\n *\n * @remarks\n * This function accepts a Uint8Array containing .lottie data and validates its structure and content.\n * It returns a Promise that resolves with an object containing a success boolean and an optional error string.\n *\n * @param dotLottie - The DotLottie data as a Uint8Array.\n * @returns A Promise that resolves with an object containing a success boolean and an optional error string.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const validationResult = await validateDotLottie(dotLottie);\n * ```\n *\n * @public\n */\nexport async function validateDotLottie(dotLottie: Uint8Array): Promise<{ error?: string; success: boolean }> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    return { success: false, error: 'DotLottie not found' };\n  }\n\n  const manifest = await getManifest(dotLottie);\n\n  if (typeof manifest === 'undefined') {\n    return { success: false, error: 'Invalid .lottie file, manifest.json is missing' };\n  }\n\n  const manifestValidationResult = safeParse(ManifestSchema, manifest);\n\n  if (!manifestValidationResult.success) {\n    const error = `Invalid .lottie file, manifest.json structure is invalid, ${JSON.stringify(\n      flatten(manifestValidationResult.error).nested,\n      null,\n      2,\n    )}`;\n\n    return { success: false, error };\n  }\n\n  return { success: true };\n}\n\n/**\n * Loads a .lottie file from an ArrayBuffer.\n *\n * @remarks\n * This function takes an ArrayBuffer containing .lottie data and converts it into a Uint8Array.\n * It validates the data and returns a Promise that resolves with the DotLottie data as a Uint8Array.\n *\n * @param arrayBuffer - The ArrayBuffer containing .lottie data.\n * @returns A Promise that resolves with the DotLottie data as a Uint8Array.\n * @throws {@link DotLottieError} if the data is invalid.\n *\n * @example\n * ```typescript\n * const arrayBuffer = new ArrayBuffer(...);\n * const dotLottie = await loadFromArrayBuffer(arrayBuffer);\n * ```\n *\n * @public\n */\nexport async function loadFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<Uint8Array> {\n  const dotLottie = new Uint8Array(arrayBuffer);\n\n  const validationResult = await validateDotLottie(dotLottie);\n\n  if (validationResult.error) {\n    throw new DotLottieError(validationResult.error, ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  return dotLottie;\n}\n\n/**\n * Loads a .lottie file from a given URL.\n *\n * @remarks\n * This function takes a URL string as input and fetches the .lottie file from the provided URL.\n * It returns a Promise that resolves with the DotLottie data as a Uint8Array.\n *\n * @param src - The URL source of the .lottie file.\n * @returns A Promise that resolves with the DotLottie data as a Uint8Array.\n * @throws {@link DotLottieError} if the URL is invalid or if the content type is incorrect.\n *\n * @example\n * ```typescript\n * const url = 'https://example.com/animation.lottie';\n * const dotLottie = await loadFromURL(url);\n * ```\n *\n * @public\n */\nexport async function loadFromURL(src: string): Promise<Uint8Array> {\n  if (!isValidURL(src)) {\n    throw new DotLottieError('Invalid url provided for .lottie file', ErrorCodes.INVALID_URL);\n  }\n\n  const response = await fetch(src);\n\n  const arrayBuffer = await response.arrayBuffer();\n\n  const contentType = response.headers.get('content-type');\n\n  if (!['application/zip', 'application/octet-stream'].includes(contentType || '')) {\n    throw new DotLottieError(\n      `Invalid content type for .lottie file, expected application/zip or application/octet-stream, received ${contentType}`,\n      ErrorCodes.INVALID_DOTLOTTIE,\n    );\n  }\n\n  const dotLottie = await loadFromArrayBuffer(arrayBuffer);\n\n  return dotLottie;\n}\n\n/**\n * Retrieves an audio from the given DotLottie object by its filename.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the filename of the audio to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the audio data URL or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filename - The filename of the image to get.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves with the audio data URL or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const filename = 'alarm.mp3';\n * const imageData = await getAudio(dotLottie, filename);\n * ```\n *\n * @public\n */\nexport async function getAudio(\n  dotLottie: Uint8Array,\n  filename: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const audioFilename = `audio/${filename}`;\n\n  const unzipped = await unzipDotLottieFile(dotLottie, audioFilename, filter);\n\n  if (typeof unzipped === 'undefined') {\n    return undefined;\n  }\n\n  return dataUrlFromU8(unzipped);\n}\n\n/**\n * Retrieves all audio files from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to further refine the extraction.\n * It returns a Promise that resolves to a record containing the audio data URLs mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves to a record containing the audio data URLs mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const allAudio = await getAllAudio(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getAllAudio(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const unzippedAudio = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('audio/', '');\n\n    return file.name.startsWith('audio/') && (!filter || filter({ ...file, name }));\n  });\n\n  const audio: Record<string, string> = {};\n\n  for (const audioPath in unzippedAudio) {\n    const unzippedSingleAudio = unzippedAudio[audioPath];\n\n    if (unzippedSingleAudio instanceof Uint8Array) {\n      const audioId = audioPath.replace('audio/', '');\n\n      audio[audioId] = dataUrlFromU8(unzippedSingleAudio);\n    }\n  }\n\n  return audio;\n}\n\n/**\n * Inlines audio assets for the given animations within a DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and a record containing the animations to process.\n * It identifies the audio used in the animations and replaces their references with the actual audio data.\n * This operation is performed asynchronously, and the function returns a Promise that resolves when the operation is complete.\n *\n * @param dotLottie - The DotLottie object containing the animations.\n * @param animations - A record containing the animations to process.\n * @returns A Promise that resolves when the operation is complete, returning nothing.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = { animation1: {...}, animation2: {...} };\n * await inlineAudioAssets(dotLottie, animations);\n * ```\n *\n * @public\n */\nexport async function inlineAudioAssets(\n  dotLottie: Uint8Array,\n  animations: Record<string, AnimationData>,\n): Promise<void> {\n  const audioMap = new Map<string, Set<string>>();\n\n  for (const [animationId, animationData] of Object.entries(animations)) {\n    for (const asset of animationData.assets || []) {\n      if (isAudioAsset(asset)) {\n        const audioId = asset.p;\n\n        if (!audioMap.has(audioId)) {\n          audioMap.set(audioId, new Set());\n        }\n        audioMap.get(audioId)?.add(animationId);\n      }\n    }\n  }\n\n  const unzippedAudio = await getAllAudio(dotLottie, (file) => audioMap.has(file.name));\n\n  for (const [audioId, animationIdsSet] of audioMap) {\n    const audioDataURL = unzippedAudio[audioId];\n\n    if (audioDataURL) {\n      for (const animationId of animationIdsSet) {\n        const animationData = animations[animationId];\n\n        for (const asset of animationData?.assets || []) {\n          if (isAudioAsset(asset) && asset.p === audioId) {\n            asset.p = audioDataURL;\n            asset.u = '';\n            asset.e = 1;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves an image from the given DotLottie object by its filename.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the filename of the image to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the image data URL or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filename - The filename of the image to get.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves with the image data URL or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const filename = 'image.png';\n * const imageData = await getImage(dotLottie, filename);\n * ```\n *\n * @public\n */\nexport async function getImage(\n  dotLottie: Uint8Array,\n  filename: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const imageFilename = `images/${filename}`;\n\n  const unzipped = await unzipDotLottieFile(dotLottie, imageFilename, filter);\n\n  if (typeof unzipped === 'undefined') {\n    return undefined;\n  }\n\n  return dataUrlFromU8(unzipped);\n}\n\n/**\n * Retrieves all images from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to further refine the extraction.\n * It returns a Promise that resolves to a record containing the image data URLs mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves to a record containing the image data URLs mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const images = await getImages(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getImages(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const unzippedImages = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('images/', '');\n\n    return file.name.startsWith('images/') && (!filter || filter({ ...file, name }));\n  });\n\n  const images: Record<string, string> = {};\n\n  for (const imagePath in unzippedImages) {\n    const unzippedImage = unzippedImages[imagePath];\n\n    if (unzippedImage instanceof Uint8Array) {\n      const imageId = imagePath.replace('images/', '');\n\n      images[imageId] = dataUrlFromU8(unzippedImage);\n    }\n  }\n\n  return images;\n}\n\n/**\n * Inlines image assets for the given animations within a DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and a record containing the animations to process.\n * It identifies the images used in the animations and replaces their references with the actual image data.\n * This operation is performed asynchronously, and the function returns a Promise that resolves when the operation is complete.\n *\n * @param dotLottie - The DotLottie object containing the animations.\n * @param animations - A record containing the animations to process.\n * @returns A Promise that resolves when the operation is complete, returning nothing.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = { animation1: {...}, animation2: {...} };\n * await inlineImageAssets(dotLottie, animations);\n * ```\n *\n * @public\n */\nexport async function inlineImageAssets(\n  dotLottie: Uint8Array,\n  animations: Record<string, AnimationData>,\n): Promise<void> {\n  const imagesMap = new Map<string, Set<string>>();\n\n  for (const [animationId, animationData] of Object.entries(animations)) {\n    for (const asset of animationData.assets || []) {\n      if (isImageAsset(asset)) {\n        const imageId = asset.p;\n\n        if (!imagesMap.has(imageId)) {\n          imagesMap.set(imageId, new Set());\n        }\n        imagesMap.get(imageId)?.add(animationId);\n      }\n    }\n  }\n\n  const unzippedImages = await getImages(dotLottie, (file) => imagesMap.has(file.name));\n\n  for (const [imageId, animationIdsSet] of imagesMap) {\n    const imageDataURL = unzippedImages[imageId];\n\n    if (imageDataURL) {\n      for (const animationId of animationIdsSet) {\n        const animationData = animations[animationId];\n\n        for (const asset of animationData?.assets || []) {\n          if (isImageAsset(asset) && asset.p === imageId) {\n            asset.p = imageDataURL;\n            asset.u = '';\n            asset.e = 1;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves an animation from the given DotLottie object by its ID.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the animation ID to retrieve, and an optional inlineAssets option.\n * It returns a Promise that resolves to the animation data or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param animationId - The animation ID to get.\n * @param options - An object containing an optional `inlineAssets` boolean to control whether image assets should be inlined.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves with the animation data or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animationId = 'example';\n * const animationData = await getAnimation(dotLottie, animationId, { inlineAssets: true });\n * ```\n *\n * @public\n */\nexport async function getAnimation(\n  dotLottie: Uint8Array,\n  animationId: string,\n  { inlineAssets }: { inlineAssets?: boolean } = {},\n  filter?: UnzipFileFilter,\n): Promise<AnimationData | undefined> {\n  const animationFilename = `animations/${animationId}.json`;\n\n  const unzippedAnimation = await unzipDotLottieFile(dotLottie, animationFilename, filter);\n\n  if (typeof unzippedAnimation === 'undefined') {\n    return undefined;\n  }\n\n  const animationData = JSON.parse(strFromU8(unzippedAnimation, false)) as AnimationData;\n\n  if (!inlineAssets) {\n    return animationData;\n  }\n\n  const animationsMap = {\n    [animationId]: animationData,\n  };\n\n  await inlineImageAssets(dotLottie, animationsMap);\n\n  await inlineAudioAssets(dotLottie, animationsMap);\n\n  return animationData;\n}\n\n/**\n * Retrieves the animations from the given DotLottie object, with optional filtering and asset inlining.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, an optional inlineAssets option, and an optional filter function.\n * It returns a Promise that resolves to a record containing the animation data mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param options - An object containing an optional `inlineAssets` boolean to control whether assets should be inlined.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the animation data mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = await getAnimations(dotLottie, { inlineAssets: true });\n * ```\n *\n * @public\n */\nexport async function getAnimations(\n  dotLottie: Uint8Array,\n  { inlineAssets }: { inlineAssets?: boolean } = {},\n  filter?: UnzipFileFilter,\n): Promise<Record<string, AnimationData>> {\n  const animationsMap: Record<string, AnimationData> = {};\n  const unzippedAnimations = await unzipDotLottie(dotLottie, (file) => {\n    const filename = file.name.replace('animations/', '').replace('.json', '');\n\n    return file.name.startsWith('animations/') && (!filter || filter({ ...file, name: filename }));\n  });\n\n  for (const animationPath in unzippedAnimations) {\n    const data = unzippedAnimations[animationPath];\n\n    if (data instanceof Uint8Array) {\n      const animationId = animationPath.replace('animations/', '').replace('.json', '');\n      const animationData = JSON.parse(strFromU8(data, false)) as AnimationData;\n\n      animationsMap[animationId] = animationData;\n    }\n  }\n\n  if (!inlineAssets) {\n    return animationsMap;\n  }\n\n  await inlineImageAssets(dotLottie, animationsMap);\n\n  return animationsMap;\n}\n\n/**\n * Retrieves the themes from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to refine the extraction of themes.\n * It returns a Promise that resolves to a record containing the themes mapped by their ID.\n *\n * @param dotLottie - The DotLottie object containing the themes.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the themes mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const themes = await getThemes(dotLottie);\n * ```\n */\nexport async function getThemes(\n  dotLottie: Uint8Array,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, Record<string, unknown>>> {\n  const themesMap: Record<string, Record<string, unknown>> = {};\n\n  const unzippedThemes = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('themes/', '').replace('.json', '');\n\n    return file.name.startsWith('themes/') && (!filter || filter({ ...file, name }));\n  });\n\n  for (const themePath in unzippedThemes) {\n    const data = unzippedThemes[themePath];\n\n    if (data instanceof Uint8Array) {\n      const themeId = themePath.replace('themes/', '').replace('.json', '');\n\n      themesMap[themeId] = JSON.parse(strFromU8(data, false));\n    }\n  }\n\n  return themesMap;\n}\n\n/**\n * Retrieves a specific theme by ID from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the theme ID to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the theme as a string or `undefined` if not found.\n *\n * @param dotLottie - The DotLottie object containing the theme.\n * @param themeId - The ID of the theme to retrieve.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to the theme as a string or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const themeId = 'dark';\n * const theme = await getTheme(dotLottie, themeId);\n * ```\n */\nexport async function getTheme(\n  dotLottie: Uint8Array,\n  themeId: string,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, unknown> | undefined> {\n  const themeFilename = `themes/${themeId}.json`;\n\n  const unzippedTheme = await unzipDotLottieFile(dotLottie, themeFilename, filter);\n\n  if (typeof unzippedTheme === 'undefined') {\n    return undefined;\n  }\n\n  return JSON.parse(strFromU8(unzippedTheme, false));\n}\n\n/**\n * Retrieves the state machines from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to refine the extraction of state machines.\n * It returns a Promise that resolves to a record containing the state machines mapped by their ID.\n *\n * @param dotLottie - The DotLottie object containing the state machines.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the state machines mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const machines = await getStateMachines(dotLottie);\n * ```\n */\nexport async function getStateMachines(\n  dotLottie: Uint8Array,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, string>> {\n  const statesMap: Record<string, string> = {};\n\n  const unzippedStates = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('states/', '').replace('.json', '');\n\n    return file.name.startsWith('states/') && (!filter || filter({ ...file, name }));\n  });\n\n  for (const statePath in unzippedStates) {\n    const data = unzippedStates[statePath];\n\n    if (data instanceof Uint8Array) {\n      const themeId = statePath.replace('states/', '').replace('.json', '');\n\n      statesMap[themeId] = strFromU8(data, false);\n    }\n  }\n\n  return statesMap;\n}\n\n/**\n * Retrieves a specific state machine by ID from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the state ID to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the state machine as a string or `undefined` if not found.\n *\n * @param dotLottie - The DotLottie object containing the theme.\n * @param stateMachineId - The ID of the state machine to retrieve.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to the state machine as a string or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const stateMachineId = 'walk';\n * const stateMachine = await getState(dotLottie, stateMachineId);\n * ```\n */\nexport async function getStateMachine(\n  dotLottie: Uint8Array,\n  stateMachineId: string,\n  filter?: UnzipFileFilter,\n): Promise<LottieStateMachine | undefined> {\n  const stateMachineFilename = `states/${stateMachineId}.json`;\n\n  const unzippedStateMachine = await unzipDotLottieFile(dotLottie, stateMachineFilename, filter);\n\n  if (typeof unzippedStateMachine === 'undefined') {\n    return undefined;\n  }\n\n  const stateMachine = JSON.parse(strFromU8(unzippedStateMachine, false)) as LottieStateMachine;\n\n  return stateMachine;\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport {\n  object,\n  type Output,\n  string,\n  array,\n  boolean,\n  number,\n  union,\n  optional,\n  record,\n  any,\n  nativeEnum,\n  literal,\n} from 'valibot';\n\nexport enum PlayMode {\n  Bounce = 'bounce',\n  Normal = 'normal',\n}\n\nexport const PlayModeSchema = nativeEnum(PlayMode);\n\nexport const ManifestAnimationSchema = object({\n  autoplay: optional(boolean()),\n  defaultTheme: optional(string()),\n  direction: optional(union([literal(1), literal(-1)])),\n  hover: optional(boolean()),\n  id: string(),\n  intermission: optional(number()),\n  loop: optional(union([boolean(), number()])),\n  playMode: optional(PlayModeSchema),\n  speed: optional(number()),\n  themeColor: optional(string()),\n});\nexport type ManifestAnimation = Output<typeof ManifestAnimationSchema>;\n\nexport const ManifestThemeSchema = object({\n  animations: array(string()),\n  id: string(),\n});\nexport type ManifestTheme = Output<typeof ManifestThemeSchema>;\n\nexport const ManifestSchema = object({\n  activeAnimationId: optional(string()),\n  animations: array(ManifestAnimationSchema),\n  author: optional(string()),\n  custom: optional(record(string(), any())),\n  description: optional(string()),\n  generator: optional(string()),\n  keywords: optional(string()),\n  revision: optional(number()),\n  themes: optional(array(ManifestThemeSchema)),\n  states: optional(array(string())),\n  version: optional(string()),\n});\n\nexport type Manifest = Output<typeof ManifestSchema>;\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { ZipOptions } from 'fflate';\n\nimport type { LottieAnimationCommon } from './lottie-animation-common';\nimport { dataUrlFromU8, DotLottieError, ErrorCodes } from './utils';\n\nexport type AudioData = string | ArrayBuffer | Blob;\n\nexport interface AudioOptions {\n  data?: AudioData;\n  fileName: string;\n  id: string;\n  parentAnimations?: LottieAnimationCommon[];\n  url?: string;\n  zipOptions?: ZipOptions;\n}\n\nexport class LottieAudioCommon {\n  protected _data?: AudioData;\n\n  protected _id: string = '';\n\n  protected _url?: string;\n\n  protected _fileName: string = '';\n\n  protected _parentAnimations: LottieAnimationCommon[];\n\n  protected _zipOptions: ZipOptions;\n\n  public constructor(options: AudioOptions) {\n    this._requireValidId(options.id);\n    this._requireValidFileName(options.fileName);\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    if (options.data) {\n      this._data = options.data;\n    }\n\n    if (options.id) {\n      this._id = options.id;\n    }\n\n    if (options.url) {\n      this._url = options.url;\n    }\n\n    if (options.fileName) {\n      this._fileName = options.fileName;\n    }\n\n    this._parentAnimations = options.parentAnimations || [];\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  public get fileName(): string {\n    return this._fileName;\n  }\n\n  public set fileName(fileName: string) {\n    if (!fileName) throw new DotLottieError('Invalid audio file name', ErrorCodes.ASSET_NOT_FOUND);\n    this._fileName = fileName;\n  }\n\n  public get id(): string {\n    return this._id;\n  }\n\n  public set id(id: string) {\n    if (!id) throw new DotLottieError('Invalid audio id', ErrorCodes.ASSET_NOT_FOUND);\n    this._id = id;\n  }\n\n  public get data(): AudioData | undefined {\n    return this._data;\n  }\n\n  public set data(data: AudioData | undefined) {\n    if (!data) {\n      throw new DotLottieError('Invalid data');\n    }\n\n    this._data = data;\n  }\n\n  public get parentAnimations(): LottieAnimationCommon[] {\n    return this._parentAnimations;\n  }\n\n  public set parentAnimations(parentAnimations: LottieAnimationCommon[]) {\n    this._parentAnimations = parentAnimations;\n  }\n\n  public async toDataURL(): Promise<string> {\n    if (this._data && this._isDataURL(this._data)) return this.data as string;\n\n    const arrayBuffer = await this.toArrayBuffer();\n\n    return dataUrlFromU8(new Uint8Array(arrayBuffer));\n  }\n\n  /**\n   * Renames the id and fileName to newName.\n   * @param newName - A new id and filename for the audio.\n   */\n  public renameAudio(newName: string): void {\n    this.id = newName;\n\n    if (this.fileName) {\n      let fileExt = this.fileName.split('.').pop();\n\n      if (!fileExt) {\n        fileExt = '.png';\n      }\n      // Default to png if the file extension isn't available\n      this.fileName = `${newName}.${fileExt}`;\n    }\n  }\n\n  public async toArrayBuffer(): Promise<ArrayBuffer> {\n    const blob = await (await this.toBlob()).arrayBuffer();\n\n    return blob;\n  }\n\n  public async toBlob(): Promise<Blob> {\n    if (!this._data && this._url) {\n      this._data = await this._fromUrlToBlob(this._url);\n    }\n\n    if (!this._data) {\n      throw new Error('Invalid data');\n    }\n\n    if (this._isDataURL(this._data)) {\n      const data = this._data as string;\n\n      const [header, base64] = data.split(',');\n\n      // If the data doesnt contain the encoding URL, return it\n      if ((!header || !base64) && data.length) {\n        return new Blob([data]);\n      }\n\n      if (!header || !base64) {\n        throw new Error('Invalid data');\n      }\n\n      // eslint-disable-next-line require-unicode-regexp\n      const type = header.replace('data:', '').replace(/;base64$/, '');\n\n      return new Blob([base64], { type });\n    }\n\n    if (this._isArrayBuffer(this._data)) {\n      return new Blob([this._data]);\n    }\n\n    if (this._isBlob(this._data)) {\n      return this._data as Blob;\n    }\n\n    throw new Error('Invalid data');\n  }\n\n  protected async _fromUrlToBlob(url: string): Promise<Blob> {\n    const response = await fetch(url);\n\n    return response.blob();\n  }\n\n  protected _isArrayBuffer(data: AudioData): boolean {\n    return data instanceof ArrayBuffer;\n  }\n\n  protected _isDataURL(data: AudioData): boolean {\n    return typeof data === 'string' && data.startsWith('data:');\n  }\n\n  protected _isBlob(data: AudioData): boolean {\n    return data instanceof Blob;\n  }\n\n  /**\n   * Ensure that the provided id is a valid string.\n   * The id must be a non-empty string, otherwise an error will be thrown.\n   * @param id - The id to validate.\n   * @throws Error - if the id is not a valid string.\n   */\n  private _requireValidId(id: string | undefined): asserts id is string {\n    if (!id) throw new DotLottieError('Invalid audio id');\n  }\n\n  /**\n   * Ensure that the provided fileName is a valid string.\n   * The fileName must be a non-empty string, otherwise an error will be thrown.\n   * @param fileName - The fileName to validate.\n   * @throws Error - if the fileName is not a valid string.\n   */\n  private _requireValidFileName(fileName: string | undefined): asserts fileName is string {\n    if (!fileName) throw new DotLottieError('Invalid audio fileName');\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { AudioOptions } from './common';\nimport { LottieAudioCommon } from './common';\n\nexport class LottieAudio extends LottieAudioCommon {\n  public constructor(options: AudioOptions) {\n    super(options);\n  }\n}\n"]}